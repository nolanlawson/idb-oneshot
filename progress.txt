Phase 0: Project Scaffolding — COMPLETE
  - Created package.json (type: "module", better-sqlite3 + typescript deps)
  - Created tsconfig.json (strict, NodeNext, allowImportingTsExtensions)
  - Created CLAUDE.md with project conventions and commands
  - Created empty src/index.ts barrel export
  - Created .gitignore (node_modules, manifest, sqlite files)
  - Created test/wpt-harness-setup.ts (browser global shims for Node)
  - Created test/wpt-subprocess.ts (child process entry that loads testharness.js + test)
  - Created test/wpt-runner.ts (forks subprocess, parses JSON results, reports per-subtest)
  - Created test/run-all.ts (runs all .any.js files, generates manifest)
  - Verified: runner executes idbkeyrange.any.js, detects 10 subtests (all fail as expected - IDBKeyRange not yet implemented)
  - Verified: npx tsc --noEmit passes clean

Phase 1: IDBKeyRange + Key Validation + IDBFactory.cmp() — COMPLETE
  - Created src/types.ts (IDBKey, IDBValidKey type definitions)
  - Created src/errors.ts (DOMException helper factories for all IDB error types)
  - Created src/keys.ts (key validation via valueToKey/valueToKeyOrThrow, cross-type comparison via compareKeys, binary-comparable encoding via encodeKey)
  - Created src/IDBKeyRange.ts (only, lowerBound, upperBound, bound static methods + includes instance method)
  - Created src/IDBFactory.ts (cmp method; open/deleteDatabase/databases stubs for Phase 2)
  - Created src/DOMStringList.ts (length, item, contains, indexed access, Symbol.iterator)
  - Created stub classes: IDBRequest, IDBOpenDBRequest, IDBDatabase, IDBTransaction, IDBObjectStore, IDBIndex, IDBCursor, IDBCursorWithValue, IDBVersionChangeEvent
  - Updated src/index.ts barrel export with all classes
  - Updated test/wpt-harness-setup.ts to inject all IDB globals into test subprocess
  - WPT results (55/55 subtests passing):
    - idbkeyrange.any.js: 10/10 PASS
    - idbkeyrange-includes.any.js: 11/11 PASS
    - idbkeyrange_incorrect.any.js: 7/7 PASS
    - idbfactory_cmp.any.js: 12/12 PASS
    - historical.any.js: 15/15 PASS
  - key_valid.any.js, key_invalid.any.js, keyorder.any.js deferred to Phase 2 (require indexedDB.open)
  - npx tsc --noEmit passes clean

Phase 2: IDBFactory.open() + Database Lifecycle — COMPLETE
  - Created src/sqlite-backend.ts (SQLiteBackend class wrapping better-sqlite3: metadata DB, per-database files, CRUD for object stores/records/indexes, savepoint management)
  - Created src/scheduling.ts (queueTask via setTimeout(0) for async event dispatch)
  - Implemented src/IDBFactory.ts:
    - open(name, version): async open with version validation, upgrade transaction lifecycle, IDBVersionChangeEvent dispatch
    - deleteDatabase(name): async delete with versionchange notification to open connections, proper oldVersion tracking
    - databases(): returns list from metadata DB
    - Connection tracking for versionchange event dispatch (skips closed connections)
  - Implemented src/IDBDatabase.ts:
    - Connection properties: name, version, objectStoreNames (live from backend)
    - createObjectStore(): validates version change context, creates store in SQLite, updates transaction scope
    - deleteObjectStore(): validates context, deletes store and related records/indexes
    - transaction(): creates IDBTransaction with store name validation, auto-commit via microtask
    - close(): marks connection as closing to prevent new transactions
    - dispatchEvent override: wires on* handler properties to addEventListener pattern
  - Implemented src/IDBTransaction.ts:
    - Transaction lifecycle: active → inactive → committing → finished
    - objectStore(): SameObject-cached IDBObjectStore instances
    - abort(): rolls back SQLite savepoint, fires abort event, notifies DB for versionchange
    - commit()/auto-commit: releases savepoint, fires complete event
    - _createRequest(): creates IDBRequest with proper transaction binding
    - dispatchEvent override for on* handlers
    - Factory function pattern to break circular IDBObjectStore dependency
  - Implemented src/IDBObjectStore.ts:
    - CRUD operations: put(), add(), get(), getKey(), delete(), clear(), count()
    - Key path evaluation and injection for in-line keys
    - Auto-increment key generation
    - createIndex()/deleteIndex() for versionchange transactions
    - All operations fire events asynchronously via queueTask
  - Implemented src/IDBRequest.ts:
    - dispatchEvent override: temporarily registers on* handler as addEventListener listener for correct event.target
  - Updated src/IDBVersionChangeEvent.ts (unchanged, already working from Phase 1)
  - Updated src/types.ts: added global IDBTransactionMode type declaration
  - Updated src/index.ts: registers IDBObjectStore factory function to break circular dependency
  - Updated test/wpt-harness-setup.ts: added addEventListener/removeEventListener/dispatchEvent on globalThis for async test support
  - Updated test/wpt-subprocess.ts: added keepAliveInterval to prevent premature process exit during async tests
  - WPT results (90/92 subtests passing across Phase 1+2):
    Phase 1 (55/55 — unchanged):
    - idbkeyrange.any.js: 10/10 PASS
    - idbkeyrange-includes.any.js: 11/11 PASS
    - idbkeyrange_incorrect.any.js: 7/7 PASS
    - idbfactory_cmp.any.js: 12/12 PASS
    - historical.any.js: 15/15 PASS
    Phase 2 (35/37):
    - idbfactory_open.any.js: 28/29 PASS (1 fail requires cursor/index — Phase 4/5)
    - idbfactory-open-request-success.any.js: 1/1 PASS
    - idbfactory-open-request-error.any.js: 0/1 FAIL (requires unique index constraint — Phase 4)
    - idbfactory-open-error-properties.any.js: 1/1 PASS
    - idbfactory_deleteDatabase.any.js: 4/4 PASS
    - idbfactory-deleteDatabase-request-success.any.js: 1/1 PASS
    - idbversionchangeevent.any.js: 1/1 PASS
  - Deferred key tests now partially work with open():
    - key_valid.any.js: 14/18 (4 fail: Date/Infinity serialization — Phase 10 structured clone)
    - key_invalid.any.js: 33/34 (1 fail: Proxy array detection in put context)
    - keyorder.any.js: 12/24 (12 fail: require cursor — Phase 5)
  - npx tsc --noEmit passes clean

Phase 3: Object Store CRUD — COMPLETE
  - Implemented IDBKeyRange query support in get(), getKey(), delete(), count()
    - All methods now accept both exact keys and IDBKeyRange objects
    - Added queryToRange() helper for consistent key/range handling
    - Added getRecordInRange(), deleteRecordsInRange() to SQLiteBackend with _buildRangeQuery helper
    - count() now correctly filters by exact key or range
  - Implemented key path validation (isValidKeyPath/isValidKeyPathString)
    - createObjectStore now validates keyPath (SyntaxError for invalid paths)
    - createObjectStore rejects autoIncrement + empty string keyPath (InvalidAccessError)
    - createObjectStore rejects autoIncrement + array keyPath (InvalidAccessError)
    - createIndex validates keyPath
  - Fixed deleted object store detection
    - _ensureValid() now checks _deleted flag before every operation
    - deleteObjectStore() marks cached IDBObjectStore._deleted = true
    - All operations (add/put/get/getKey/delete/clear/count/createIndex/deleteIndex) throw InvalidStateError on deleted stores
  - Fixed getKey() argument validation
    - Throws TypeError when called with no arguments (per spec)
    - Returns decoded key from binary-encoded buffer for range queries
    - Added decodeKeyFromBuffer/decodeKeyAt for binary key decoding
  - Implemented unique index constraint enforcement
    - checkUniqueIndexConstraint() in SQLiteBackend checks for duplicate index keys
    - put/add check unique constraints before inserting and fire ConstraintError on violation
    - createIndex with unique:true aborts transaction if existing data violates constraint
  - Implemented index entry maintenance on put/add
    - deleteIndexEntriesForRecord() clears old entries before replacement
    - Adds new index entries for all indexes on the store after each put/add
    - Multi-entry index support: arrays are expanded into individual entries
    - _populateIndex() fills new index from existing records during createIndex
  - Improved index() stub to return proper NotFoundError for missing indexes
  - Fixed transaction auto-commit timing
    - Added _pendingRequestCount to IDBTransaction for accurate tracking
    - Separated _maybeAutoCommit() from _requestFinished() to avoid double-decrement
    - Nested requests during event handlers (e.g., count inside upgradeneeded) now work correctly
  - WPT results (93/102 subtests passing across Phase 3 target tests):
    - idbdatabase_createObjectStore.any.js: 26/27 PASS (1 fail: requires index() — Phase 4)
    - idbdatabase_deleteObjectStore.any.js: 3/3 PASS
    - idbobjectstore_add.any.js: 13/16 PASS (3 fail: require openCursor — Phase 5)
    - idbobjectstore_put.any.js: 13/16 PASS (3 fail: require openCursor — Phase 5)
    - idbobjectstore_get.any.js: 7/7 PASS
    - idbobjectstore_getKey.any.js: 17/17 PASS
    - idbobjectstore_delete.any.js: 7/7 PASS
    - idbobjectstore_clear.any.js: 2/4 PASS (2 fail: require openCursor/index — Phase 4/5)
    - idbobjectstore_count.any.js: 4/4 PASS
    - idbobjectstore_keyPath.any.js: 1/1 PASS
  - npx tsc --noEmit passes clean

Phase 4: Indexes — COMPLETE
  - Implemented full IDBIndex class (src/IDBIndex.ts):
    - Properties: name, objectStore, keyPath, unique, multiEntry
    - keyPath returns SameObject for array key paths
    - get(query): retrieves first record matching index key or range
    - getKey(query): retrieves first primary key matching index key or range
    - count(query): counts index entries, supports exact key and range queries
    - getAll/getAllKeys stubs (Phase 9)
    - openCursor/openKeyCursor stubs returning null (Phase 5)
    - _ensureValid() checks: deleted index, deleted-by-aborted-upgrade, deleted object store, inactive transaction
    - _createdInTransaction tracking for proper abort detection
  - Added SQLite backend index query methods (src/sqlite-backend.ts):
    - getRecordByIndexKey(): lookup record by exact index key with JOIN to records table
    - getRecordByIndexRange(): lookup first record in index key range
    - countIndexEntries(): count index entries with optional range filtering
  - Updated IDBObjectStore (src/IDBObjectStore.ts):
    - index() now returns real IDBIndex instances with SameObject caching
    - createIndex() returns real IDBIndex instances
    - createIndex() exception ordering: ConstraintError (name check) before SyntaxError (keyPath check)
    - createIndex() unique constraint violation: aborts transaction without throwing (returns IDBIndex)
    - deleteIndex() marks cached IDBIndex._deleted = true
    - Fixed multi-entry index entry generation: uses raw key path evaluation instead of valueToKey on arrays containing non-key elements
    - Same fix applied to _populateIndex for consistency
  - WPT results (33/34 Phase 4 subtests passing):
    - idbindex_get.any.js: 8/8 PASS
    - idbindex_getKey.any.js: 8/8 PASS
    - idbindex_count.any.js: 4/4 PASS
    - idbindex-multientry.any.js: 3/3 PASS
    - idbindex-objectStore-SameObject.any.js: 1/1 PASS
    - idbindex-request-source.any.js: 7/7 PASS
    - idbobjectstore_index.any.js: 1/1 PASS
    - idbindex_indexNames.any.js: 1/1 PASS
    - idbindex_keyPath.any.js: 1/3 (2 fail: require openCursor — Phase 5)
  - Bonus improvements from Phase 4 work:
    - idbfactory-open-request-error.any.js: now 1/1 PASS (was 0/1, needed unique index)
    - idbobjectstore_createIndex.any.js: 14/21 PASS (was 13/21, fixed ConstraintError ordering)
  - npx tsc --noEmit passes clean

Phase 5: Cursors — COMPLETE
  - Implemented full IDBCursor class (src/IDBCursor.ts):
    - Properties: key, primaryKey, direction, source, request
    - continue(key?): advance to next record, optional key target
    - advance(count): skip N records forward/backward
    - continuePrimaryKey(key, primaryKey): advance index cursor to specific key+primaryKey
    - update(value): update current record via cursor
    - delete(): delete current record via cursor
    - Proper cursor lifecycle: _gotValue/_continueCalled flags set asynchronously in event callback
    - Source validity checks (deleted store/index detection)
    - Request reuse: same IDBRequest fires success for each iteration
    - Request source set to cursor for update()/delete() per spec
  - Implemented IDBCursorWithValue (extends IDBCursor with value getter)
  - Added openObjectStoreCursor/openIndexCursor factory functions
  - Updated IDBObjectStore (src/IDBObjectStore.ts):
    - openCursor(query?, direction?): returns IDBCursorWithValue via IDBRequest
    - openKeyCursor(query?, direction?): returns IDBCursor (no value) via IDBRequest
    - Added Symbol.toStringTag for correct toString() output
    - Query validation moved before _createRequest to avoid polluting pending count on error
  - Updated IDBIndex (src/IDBIndex.ts):
    - openCursor(query?, direction?): opens cursor over index entries
    - openKeyCursor(query?, direction?): opens key-only cursor over index
    - Added Symbol.toStringTag
  - Added SQLite backend cursor methods (src/sqlite-backend.ts):
    - getRecordsForCursor(): retrieves sorted records within range for object store cursors
    - getIndexEntriesForCursor(): retrieves sorted index entries with JOIN for index cursors
    - Correct sort order for prevunique: index key DESC, primary key ASC
  - Fixed key encoding (src/keys.ts):
    - String encoding: added 0x00 0x00 terminator with NUL escape (0x00 0x01)
    - Binary encoding: added 0x00 0x00 terminator with byte stuffing
    - Added exported decodeKey() function, eliminating duplicated decoders in IDBObjectStore/IDBIndex
    - Array keys with string/binary elements now decode correctly
  - Added IDBCursorDirection global type declaration (src/types.ts)
  - WPT results (100/100 Phase 5 cursor subtests passing across 25 test files):
    - idbcursor-continue.any.js: 6/6 PASS
    - idbcursor-advance.any.js: 6/6 PASS
    - idbcursor-direction.any.js: 5/5 PASS
    - idbcursor-direction-index.any.js: 4/4 PASS
    - idbcursor-direction-objectstore.any.js: 4/4 PASS
    - idbcursor-direction-index-keyrange.any.js: 4/4 PASS
    - idbcursor-direction-objectstore-keyrange.any.js: 4/4 PASS
    - idbcursor-key.any.js: 3/3 PASS
    - idbcursor-primarykey.any.js: 3/3 PASS
    - idbcursor-source.any.js: 2/2 PASS
    - idbcursor-reused.any.js: 1/1 PASS
    - idbcursor-request.any.js: 4/4 PASS
    - idbcursor-request-source.any.js: 8/8 PASS
    - idbcursor_advance_index.any.js: 8/8 PASS
    - idbcursor_advance_objectstore.any.js: 5/5 PASS
    - idbcursor_continue_index.any.js: 10/10 PASS
    - idbcursor_continue_objectstore.any.js: 8/8 PASS
    - idbcursor_iterating.any.js: 1/1 PASS
    - cursor-overloads.any.js: 1/1 PASS
    - idbobjectstore_openCursor.any.js: 1/1 PASS
    - idbobjectstore_openCursor_invalid.any.js: 1/1 PASS
    - idbobjectstore_openKeyCursor.any.js: 5/5 PASS
    - idbindex_openCursor.any.js: 3/3 PASS
    - idbindex_openKeyCursor.any.js: 4/4 PASS
    - idbindex_reverse_cursor.any.js: 2/2 PASS
  - Bonus improvements from cursor support:
    - keyorder.any.js: now 24/24 PASS (was 12/24, needed cursor iteration)
    - idbdatabase_createObjectStore.any.js: now 27/27 PASS (was 26/27, needed index())
    - idbobjectstore_add.any.js: now 16/16 PASS (was 13/16, needed openCursor)
    - idbobjectstore_put.any.js: now 16/16 PASS (was 13/16, needed openCursor)
    - idbobjectstore_clear.any.js: now 4/4 PASS (was 2/4, needed openCursor/index)
    - idbindex_keyPath.any.js: now 3/3 PASS (was 1/3, needed openCursor)
  - npx tsc --noEmit passes clean

Phase 6: Transaction Lifecycle + Scheduling — COMPLETE
  - Created src/transaction-scheduler.ts (new file):
    - DatabaseScheduler class with per-database transaction queue
    - Scope-based locking: RW transactions block RW/RO with overlapping scopes
    - Creation order enforcement for conflicting transactions
    - Global scheduler map keyed by database name
    - Async start via queueMicrotask to avoid re-entrance
  - Major refactor: deferred SQLite operations via _queueOperation pattern
    - IDBObjectStore: all CRUD methods (add/put/get/getKey/delete/clear/count) defer both
      SQLite operations and event dispatch until scheduler starts the transaction
    - IDBIndex: get/getKey/count defer via same pattern
    - IDBCursor: openObjectStoreCursor/openIndexCursor defer via _queueOperation
    - Prevents savepoint nesting issues when transactions queue before active ones finish
  - Updated IDBTransaction (src/IDBTransaction.ts):
    - Added scheduler fields: _started, _pendingCallbacks, _useScheduler, _commitOnStart
    - _queueOperation(operation, eventCallback): buffers both when not started, executes immediately when started
    - _queueRequestCallback(callback): buffers just event callback when not started
    - _schedulerStart(): flushes buffered operations, triggers deferred auto-commit for empty transactions
    - abort/commit notify scheduler via getScheduler().transactionFinished()
    - Event bubbling: abort events bubble from transaction to database, respecting stopPropagation
  - Updated IDBDatabase (src/IDBDatabase.ts):
    - transaction() registers with scheduler via getScheduler().addTransaction()
    - Transaction deactivation via chained queueMicrotask (active through microtask checkpoint, inactive before next macrotask)
    - Store name deduplication via [...new Set(storeNames)]
    - Frozen objectStoreNames cache on close()
  - Updated IDBRequest (src/IDBRequest.ts):
    - Event bubbling: error events bubble from request to transaction to database, respecting stopPropagation/cancelBubble
    - Added Symbol.toStringTag to IDBOpenDBRequest
    - Added _constraintError flag for ConstraintError handling
  - Updated IDBObjectStore (src/IDBObjectStore.ts):
    - ConstraintError handling: unhandled error events auto-abort the transaction (per spec)
    - Error event dispatch returns notPrevented flag for abort decision
  - Updated IDBTransaction abort() for versionchange:
    - _versionChangeTransactionFinished fires in separate task after abort event propagates
  - WPT results (Phase 6 target tests):
    - transaction-scheduling-across-connections.any.js: 1/1 PASS (new)
    - transaction-scheduling-across-databases.any.js: 1/1 PASS (was passing)
    - transaction-scheduling-ordering.any.js: 1/1 PASS (new)
    - transaction-scheduling-rw-scopes.any.js: 1/1 PASS (new)
    - transaction-scheduling-mixed-scopes.any.js: 1/1 PASS (new)
    - transaction-scheduling-ro-waits-for-rw.any.js: 1/1 PASS (was passing)
    - transaction-scheduling-within-database.any.js: 1/1 PASS (was passing)
    - writer-starvation.any.js: 1/1 PASS (was passing)
    - idbtransaction.any.js: 2/2 PASS (was 1/2)
    - idbtransaction-oncomplete.any.js: 1/1 PASS (was passing)
    - idbtransaction_abort.any.js: 3/3 PASS (was 2/3)
    - idbtransaction_objectStoreNames.any.js: 7/8 PASS (was 4/8, remaining: unusual names SQLite issue)
    - transaction-deactivation-timing.any.js: 4/5 PASS (was 3/5, remaining: microtask between event listeners)
    - transaction-lifetime-empty.any.js: 2/2 PASS (was 0/2)
    - transaction-requestqueue.any.js: 1/1 PASS (was passing)
    - transaction-create_in_versionchange.any.js: 1/1 PASS (was passing)
    - upgrade-transaction-deactivation-timing.any.js: 3/3 PASS (bonus)
    - transaction-lifetime.any.js: 0/0 ERROR (needs blocked event + connection close)
    - open-request-queue.any.js: 0/0 ERROR (needs FIFO queue)
    - delete-request-queue.any.js: 0/1 FAIL (WPT test bug: this.saw vs saw)
  - No regressions in previously passing tests
  - Overall WPT pass rate: 688/1076 subtests (63.9%)
  - npx tsc --noEmit passes clean

Phase 7: Transaction Abort + Metadata Revert — COMPLETE
  - Implemented metadata revert tracking in IDBTransaction:
    - _createdStoreNames/_deletedStoreNames: track stores created/deleted during versionchange
    - _deletedStoreCache: preserve IDBObjectStore references for deleted stores
    - _createdIndexes/_deletedIndexes: track indexes created/deleted during versionchange
    - _revertMetadata(): on abort, reverts _deleted flags, objectStoreNames, indexNames
  - Updated IDBDatabase.createObjectStore():
    - Tracks created store names for abort revert
  - Updated IDBDatabase.deleteObjectStore():
    - Marks all indexes on deleted store as deleted, clears indexNames
    - Tracks deleted store names (only for pre-existing stores, not created-in-txn)
    - Preserves cached IDBObjectStore references in _deletedStoreCache
  - Updated IDBObjectStore.createIndex():
    - Tracks created indexes for abort revert
  - Updated IDBObjectStore.deleteIndex():
    - Tracks deleted indexes for abort revert (only for pre-existing indexes)
    - Creates IDBIndex reference for uncached indexes being deleted
  - Updated IDBTransaction.abort():
    - Calls _revertMetadata() for versionchange transactions
    - Fires error events on pending requests before abort event
    - Pending requests get AbortError with readyState='done'
  - Implemented proper IDB event propagation (capture/target/bubble phases):
    - Created initEventTarget() to track addEventListener/removeEventListener calls
    - Created idbDispatchEvent() for proper DOM event path with capture/bubble phases
    - Uses Object.defineProperty to set event.target correctly for all phases
    - IDBRequest.dispatchEvent: propagates through [request → transaction → database]
    - IDBTransaction.dispatchEvent: propagates through [transaction → database]
    - IDBDatabase constructor: registers with initEventTarget for listener tracking
  - WPT results (16/16 Phase 7 subtests passing):
    - transaction-abort-generator-revert.any.js: 2/2 PASS
    - transaction-abort-object-store-metadata-revert.any.js: 4/4 PASS
    - transaction-abort-index-metadata-revert.any.js: 6/6 PASS
    - transaction-abort-multiple-metadata-revert.any.js: 3/3 PASS
    - transaction-abort-request-error.any.js: 1/1 PASS
  - Bonus improvements from event propagation work:
    - request_bubble-and-capture.any.js: 1/1 PASS (new, was Phase 11)
    - transaction_bubble-and-capture.any.js: 1/1 PASS (new, was Phase 11)
  - No regressions in previously passing tests
  - Overall WPT pass rate: 702/1077 subtests (65.2%)
  - npx tsc --noEmit passes clean

Phase 8: Exception Ordering + Rename — COMPLETE
  - Fixed exception ordering in IDBCursor.advance:
    - TypeError (count=0) now precedes TransactionInactiveError per spec
  - Fixed exception ordering in IDBCursor.continuePrimaryKey:
    - Added _ensureSourceValid() call before InvalidAccessError checks
    - Deleted source check now precedes incorrect source/direction checks
  - Fixed exception ordering in IDBDatabase.createObjectStore:
    - SyntaxError (invalid keyPath) now precedes ConstraintError (duplicate name) per spec
    - InvalidStateError (not running upgrade) distinguished from TransactionInactiveError
    - Finished or aborted upgrade transactions correctly throw InvalidStateError
  - Fixed exception ordering in IDBDatabase.deleteObjectStore:
    - Same InvalidStateError vs TransactionInactiveError fix as createObjectStore
  - Fixed exception ordering in IDBDatabase.transaction:
    - NotFoundError (store not found) now precedes TypeError (invalid mode) per spec
  - Improved IDBTransaction.abort() state management:
    - State transitions: active/inactive → inactive (aborted flag set) → finished (after abort event fires)
    - Abort event handlers see transaction state as 'finished' (no longer running)
    - Code synchronously after abort() sees state as 'inactive' (still running but not active)
  - Implemented IDBObjectStore.name setter (rename):
    - Validates: versionchange transaction, not deleted, transaction active
    - ConstraintError for duplicate names, toString() exception re-raising
    - Updates SQLite backend, in-memory state, transaction cache, objectStoreNames
    - Tracks renames for abort revert
  - Implemented IDBIndex.name setter (rename):
    - Same validation pattern as object store rename
    - Updates SQLite backend, index cache, indexNames
    - Tracks renames for abort revert
  - Added SQLiteBackend methods:
    - renameObjectStore(): UPDATE object_stores SET name
    - renameIndex(): UPDATE indexes SET name
  - Updated IDBTransaction._revertMetadata() for rename abort:
    - Reverts renamed stores/indexes in reverse order
    - Skips revert for stores/indexes created in same transaction (keeps last name)
  - WPT results (Phase 8 target tests):
    Exception ordering (74/76 passing, 2 are Phase 9 getAll/getAllKeys):
    - idbcursor-advance-exception-order.any.js: 3/3 PASS (was 2/3)
    - idbcursor-continue-exception-order.any.js: 3/3 PASS (unchanged)
    - idbcursor-continuePrimaryKey-exception-order.any.js: 13/13 PASS (was 11/13)
    - idbcursor-delete-exception-order.any.js: 3/3 PASS (unchanged)
    - idbcursor-update-exception-order.any.js: 4/4 PASS (unchanged)
    - idbdatabase-createObjectStore-exception-order.any.js: 4/4 PASS (was 2/4)
    - idbdatabase-deleteObjectStore-exception-order.any.js: 2/2 PASS (was 1/2)
    - idbdatabase-transaction-exception-order.any.js: 4/4 PASS (was 3/4)
    - idbindex-query-exception-order.any.js: 12/12 PASS (unchanged)
    - idbobjectstore-add-put-exception-order.any.js: 6/6 PASS (unchanged)
    - idbobjectstore-clear-exception-order.any.js: 2/2 PASS (unchanged)
    - idbobjectstore-delete-exception-order.any.js: 3/3 PASS (unchanged)
    - idbobjectstore-deleteIndex-exception-order.any.js: 3/3 PASS (unchanged)
    - idbobjectstore-query-exception-order.any.js: 10/12 (2 fail: getAll/getAllKeys — Phase 9)
    - idbtransaction-objectStore-exception-order.any.js: 1/1 PASS (unchanged)
    Rename (28/29 passing):
    - idbobjectstore-rename-store.any.js: 10/11 PASS (1 fail: surrogate pair SQLite encoding)
    - idbobjectstore-rename-errors.any.js: 6/6 PASS
    - idbobjectstore-rename-abort.any.js: 2/2 PASS
    - idbindex-rename-errors.any.js: 6/6 PASS
    - idbindex-rename-abort.any.js: 2/2 PASS
  - Bonus improvements from abort state management:
    - idbfactory_open.any.js: 29/29 PASS (was 28/29)
    - upgrade-transaction-lifecycle-backend-aborted.any.js: 1/2 PASS (was 0/2)
    - upgrade-transaction-lifecycle-user-aborted.any.js: 3/4 PASS (was 2/4)
  - No regressions in previously passing tests
  - Overall WPT pass rate: 739/1077 subtests (68.6%), up from 702/1077 (65.2%)
  - npx tsc --noEmit passes clean

Phase 9: getAll / getAllKeys / getAllRecords — COMPLETE
  - Created src/IDBRecord.ts:
    - IDBRecord class with getter-based key/primaryKey/value properties (IDL attribute pattern)
    - Symbol.toStringTag returns 'IDBRecord' for assert_class_string compatibility
  - Implemented IDBObjectStore.getAll(queryOrOptions?, count?):
    - Supports both positional (query, count) and dictionary (IDBGetAllOptions) overloads
    - Returns array of deserialized values matching query with optional count limit
    - Direction support (next/prev/nextunique/prevunique) for dictionary overload
  - Implemented IDBObjectStore.getAllKeys(queryOrOptions?, count?):
    - Same overload support as getAll, returns decoded primary keys
  - Implemented IDBObjectStore.getAllRecords(options?):
    - Returns array of IDBRecord objects with key, primaryKey, value
    - Supports query, count, and direction options
  - Implemented IDBIndex.getAll(queryOrOptions?, count?):
    - Queries index entries, returns record values
    - Unique direction deduplication (nextunique/prevunique)
  - Implemented IDBIndex.getAllKeys(queryOrOptions?, count?):
    - Returns primary keys from index entries
    - Unique direction deduplication
  - Implemented IDBIndex.getAllRecords(options?):
    - Returns IDBRecord objects with index key, primary key, value
    - Full direction and deduplication support
  - Added [EnforceRange] count validation:
    - enforceRangeCount() rejects NaN, Infinity, -Infinity, negative values
    - Converts to unsigned 32-bit integer via >>> 0
  - Added parseGetAllArgs() helper:
    - Detects dictionary vs positional overload based on getAllRecords presence
    - Extracts query, count, direction from either form
  - Added SQLiteBackend bulk retrieval methods:
    - getAllRecords(): object store records with range, direction, optional LIMIT
    - getAllIndexEntries(): index entries with JOIN, range, direction, optional LIMIT
  - Updated barrel export (src/index.ts) and test harness (test/wpt-harness-setup.ts):
    - Exports and injects IDBRecord as global
  - WPT results (205/223 Phase 9 subtests passing, 91.9%):
    Object store tests:
    - idbobjectstore_getAll.any.js: 15/18 PASS (3 fail: large values, commit, detached buffer)
    - idbobjectstore_getAllKeys.any.js: 15/16 PASS (1 fail: detached buffer)
    - idbobjectstore_getAll-options.any.js: 22/24 PASS (2 fail: large values, detached buffer)
    - idbobjectstore_getAllKeys-options.any.js: 22/23 PASS (1 fail: detached buffer)
    - idbobjectstore_getAllRecords.any.js: 22/25 PASS (3 fail: large values, commit, detached buffer)
    - idbobjectstore-getAll-enforcerange.any.js: 1/1 PASS
    - idbobjectstore-getAllKeys-enforcerange.any.js: 1/1 PASS
    Index tests:
    - idbindex_getAll.any.js: 17/19 PASS (2 fail: large values, detached buffer)
    - idbindex_getAllKeys.any.js: 17/18 PASS (1 fail: detached buffer)
    - idbindex_getAll-options.any.js: 24/26 PASS (2 fail: large values, detached buffer)
    - idbindex_getAllKeys-options.any.js: 24/25 PASS (1 fail: detached buffer)
    - idbindex_getAllRecords.any.js: 23/25 PASS (2 fail: large values, detached buffer)
    - idbindex-getAll-enforcerange.any.js: 1/1 PASS
    - idbindex-getAllKeys-enforcerange.any.js: 1/1 PASS
  - Remaining failures are cross-cutting issues:
    - "large values": Array type not preserved by JSON serialization (Phase 10 structured clone)
    - "detached TypedArray/ArrayBuffer": detached buffer detection (Phase 10)
    - "transaction.commit()": explicit commit before request completion (Phase 12)
  - Bonus improvements:
    - idbobjectstore-query-exception-order.any.js: 12/12 PASS (was 10/12, getAll/getAllKeys now implemented)
  - No regressions in previously passing tests
  - npx tsc --noEmit passes clean

Phase 10: Structured Clone + Key Generator + Key Path Edge Cases — COMPLETE
  - Created src/structured-clone.ts:
    - serialize(): uses v8.serialize() for full structured clone support (BigInt, Date, RegExp,
      ArrayBuffer, TypedArrays, Map, Set, Error subtypes, circular references, primitive wrappers)
    - deserialize(): uses v8.deserialize() with JSON.parse fallback for legacy data
    - cloneValue(): uses structuredClone() for clone-before-keypath-eval with proper error propagation
    - Throws DataCloneError for non-serializable types (functions, Symbols, etc.)
  - Created src/keypath.ts:
    - Unicode identifier support via \p{ID_Start}/\p{ID_Continue} regex (supports Norwegian ø, etc.)
    - evaluateKeyPath(): handles string .length property, Blob .size/.type, File .name/.lastModified
    - evaluateKeyPathDetailed(): distinguishes "property not found" from "found but not a valid key"
    - extractKeyFromValue(), injectKeyIntoValue(), canInjectKey() extracted from IDBObjectStore
    - isValidKeyPath()/isValidKeyPathString() with proper Unicode support
  - Updated IDBObjectStore._addOrPut():
    - Clone-before-keypath-eval: value is structuredClone'd before key extraction
    - Transaction temporarily set to inactive during cloning (structured-clone-transaction-state tests)
    - Errors from enumerable getters during cloning propagate through (not wrapped in DataCloneError)
    - Key extraction operates on the clone, not the original value
    - Invalid key detection: key path resolving to non-key value throws DataError (not autoIncrement)
    - canInjectKey() check for multi-segment key paths (e.g., {a: 123} with keyPath 'a.b.id')
  - Fixed key generator overflow:
    - _nextKey(): returns null when current key >= 2^53 (9007199254740992)
    - _maybeUpdateKeyGenerator(): handles Infinity (maxes out generator), NaN (no-op),
      caps at 2^53 so future generation fails with ConstraintError
    - All 11 big_key_test cases pass including Infinity, negative values, powers of 2
  - WebIDL key path stringification:
    - createObjectStore() and createIndex() now stringify array elements and non-string keyPaths
    - Handles [['x'], ['y']] → ['x', 'y'], {toString: () => 'y'} → 'y', loop_array → ['']
  - Replaced all JSON.stringify/JSON.parse with v8 serialize/deserialize:
    - IDBObjectStore: put/add, get, getAll, getAllKeys, getAllRecords, _populateIndex
    - IDBCursor: object store cursors, index cursors, advance, continue, continuePrimaryKey
    - IDBIndex: get, getAll, getAllKeys, getAllRecords
  - Added IDBRequest Symbol.toStringTag ('IDBRequest') for assert_class_string compatibility
  - Added browser API shims in test harness:
    - DOMMatrix, DOMMatrixReadOnly, DOMPoint, DOMPointReadOnly, DOMRect, DOMRectReadOnly
    - ImageData (minimal constructor for width/height/data)
  - WPT results (Phase 10 target tests):
    - keygenerator.any.js: 21/21 PASS (new)
    - keypath.any.js: 20/20 PASS (new)
    - keypath_invalid.any.js: 24/24 PASS (new)
    - keypath_maxsize.any.js: 3/3 PASS (new)
    - keypath-exceptions.any.js: 4/6 PASS (2 fail: Object.prototype getter edge case in Node)
    - keypath-special-identifiers.any.js: 2/6 PASS (4 fail: Blob/File not preserved by v8.serialize)
    - clone-before-keypath-eval.any.js: 5/5 PASS (new)
    - structured-clone-transaction-state.any.js: 3/3 PASS (new)
    - value.any.js: 8/8 PASS (new)
    - value_recursive.any.js: 3/3 PASS (new)
    - structured-clone.any.js: 4/124 PASS (most fail: promise_test transaction timing — Phase 11)
    - nested-cloning-basic.any.js: 1/2 PASS (1 fail: Blob not preserved by v8.serialize)
    - nested-cloning-small.any.js: 0/6 FAIL (Blob data issues)
    - nested-cloning-large.any.js: 1/7 PASS (Blob/large data issues)
    - nested-cloning-large-multiple.any.js: 0/2 FAIL (Blob data issues)
  - Bonus improvements from structured clone:
    - key_valid.any.js: 18/18 PASS (was 14/18, Date/Infinity now serialized correctly)
    - key_invalid.any.js: 33/34 PASS (unchanged)
  - Remaining failures are cross-cutting issues:
    - Blob/File: v8.serialize doesn't handle Blob natively; needs custom serialization (future)
    - structured-clone.any.js: promise_test + await pattern causes TransactionInactiveError (Phase 11)
    - Object.prototype getters: Node's structuredClone accesses enumerable prototype getters
  - No regressions in previously passing tests
  - Overall WPT pass rate: 1017/1234 subtests (82.4%), up from 739/1077 (68.6%)
  - npx tsc --noEmit passes clean

Phase 11: Event Bubbling + Error Handling — COMPLETE
  - Rewrote idbDispatchEvent() in scheduling.ts for exception-safe event dispatch:
    - invokeListeners() wraps each listener call in try/catch; exceptions are caught
      and reported but do not prevent subsequent listeners from being called
    - New invokeTargetListeners() handles target-phase dispatch with same try/catch pattern
    - Replaced native EventTarget.dispatchEvent calls with custom listener invocation
      for consistent exception handling across all IDB event targets
    - addEventListener wrapper catches errors from Node's native addEventListener
      (handles handleEvent getter throws during registration)
    - idbDispatchEvent sets _exceptionThrown flag on events for callers to check
    - reportListenerException() silently swallows errors (IDB spec says abort, not crash)
  - Created IDBTransaction._dispatchRequestEvent() centralized dispatch helper:
    - Sets transaction active before dispatch
    - Checks for exceptions → aborts transaction with AbortError
    - Checks for unhandled error events (not preventDefault'd) → aborts with request's error
    - Keeps transaction active through microtask checkpoint via queueMicrotask→queueMicrotask
    - Deactivation + requestFinished happen after microtask checkpoint completes
  - Updated all event dispatch sites across IDBObjectStore, IDBIndex, IDBCursor:
    - All 15+ dispatch callbacks now use _dispatchRequestEvent instead of manual pattern
    - Removed redundant _state = 'active' / _deactivate() / _requestFinished() from each callback
  - Updated IDBRequest.dispatchEvent:
    - Removed _suppressBubble mechanism; all dispatches go through idbDispatchEvent
    - Simplified to always use idbDispatchEvent with appropriate ancestor list
  - Updated IDBTransaction.dispatchEvent:
    - Simplified to always use idbDispatchEvent
  - Updated IDBDatabase.dispatchEvent:
    - Simplified to always use idbDispatchEvent (added import)
  - Fixed error-attributes: tx.error preserves request's error (e.g., ConstraintError):
    - _dispatchRequestEvent sets this._error = request._error BEFORE calling abort()
    - abort() only sets AbortError if _error is not already set
  - Fixed upgradeneeded exception handling in IDBFactory._runOpenSteps:
    - Checks _exceptionThrown on upgradeneeded event after dispatch
    - If exception thrown, aborts upgrade transaction immediately
  - WPT results (Phase 11 target tests — 37/40 subtests passing):
    - event-dispatch-active-flag.any.js: 4/4 PASS (was 0/4)
    - fire-error-event-exception.any.js: 17/17 PASS (was 0/0 ERROR)
    - fire-success-event-exception.any.js: 6/6 PASS (was 0/0 ERROR)
    - fire-upgradeneeded-event-exception.any.js: 6/6 PASS (was 0/0 ERROR)
    - error-attributes.any.js: 1/1 PASS (was 0/1)
    - request_bubble-and-capture.any.js: 1/1 PASS (unchanged)
    - transaction_bubble-and-capture.any.js: 1/1 PASS (unchanged)
    - idbrequest-onupgradeneeded.any.js: 1/4 PASS (unchanged, 3 fail: require blocked
      connection/open request queue — Phase 12 upgrade lifecycle)
    - idbrequest_error.any.js: 1/1 PASS (unchanged)
    - idbrequest_result.any.js: 1/1 PASS (unchanged)
  - Bonus improvements from microtask-based deactivation:
    - Many tests benefit from transaction staying active through microtask checkpoint
    - structured-clone.any.js: improved from 4/124 to significant gains
      (promise_test pattern now works because tx stays active through microtasks)
  - No regressions in previously passing tests
  - Overall WPT pass rate: 1184/1272 subtests (93.1%), up from 1017/1234 (82.4%)
  - npx tsc --noEmit passes clean

Phase 12: Upgrade Transaction Lifecycle — COMPLETE
  - Fixed upgrade transaction abort timing in IDBTransaction.abort():
    - _versionChangeTransactionFinished now called synchronously after abort event fires
      (was in a separate queueTask, causing request.transaction to not be cleared before
       setTimeout(0) callbacks from abort handlers)
    - request.transaction is now properly null in setTimeout(0) after onabort
  - Implemented close-in-upgradeneeded behavior in IDBFactory._runOpenSteps:
    - When db.close() is called during onupgradeneeded, the upgrade transaction commits
      normally (complete event fires), but the connection is not opened
    - _onVersionChangeComplete callback checks db._closePending after successful commit
    - If closePending, fires error event with AbortError on open request instead of success
    - request.result is cleared to undefined, matching spec behavior
  - WPT results (13/13 Phase 12 subtests passing):
    - upgrade-transaction-deactivation-timing.any.js: 3/3 PASS (unchanged)
    - upgrade-transaction-lifecycle-backend-aborted.any.js: 2/2 PASS (was 1/2)
    - upgrade-transaction-lifecycle-committed.any.js: 2/2 PASS (unchanged)
    - upgrade-transaction-lifecycle-user-aborted.any.js: 4/4 PASS (was 3/4)
    - abort-in-initial-upgradeneeded.any.js: 1/1 PASS (unchanged)
    - close-in-upgradeneeded.any.js: 1/1 PASS (was 0/1)
  - No regressions in previously passing tests
  - Overall WPT pass rate: 1188/1272 subtests (93.4%), up from 1184/1272 (93.1%)
  - npx tsc --noEmit passes clean

Next: Phase 13 — Remaining Tests
